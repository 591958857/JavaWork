## 标记：可达性分析 ##
可达性分析的GC Root对象：

1. 当前正在执行的方法里的局部变量和输入参数；
1. 活动线程（Active threads）；
1. 所有类的静态字段（static field）；
1. JNI 引用；

## 基本算法 ##
1. 标记、复制算法；
1. 标记、清除、整理算法；
1. 标记、清除算法；

## 串行GC（Serial GC） ##

### 堆区内存模型 ###
- 	堆 = 年轻代 + 老年代；
- 	年轻代 = Eden区 + S0区 + S1区；

###默认比例###
- 	年轻代 : 老年代 = 1:2
- 	Edem : S0: S1 = 8:1:1
 	
###相关GC算法###
- 	年轻代回收算法：标记、复制算法（串行，业务线程暂停）；
- 	老年代回收算法：标记、清除、整理算法（串行，业务线程暂停）；

###相关要点###
- 	单线程垃圾回收器，不能并行处理，年轻代和老年代回收垃圾时都会触	
- 	发STW，效率低；

###适用场景###
- 	只有几百MB堆内存的JVM，且是单核CPU时比较有用；

###使用命令###
- 	-XX:+UseSerialGC

##并行GC（Parallel GC）##

###堆区内存模型###
- 堆 = 年轻代 + 老年代；
- 年轻代 = Eden区 + S0区 + S1区；

###默认比例###
- 年轻代 : 老年代 = 1:2
- Edem : S0: S1 = 8:1:1

###相关GC算法###
- 年轻代回收算法：标记、复制算法（GC并行，业务线程暂停）；
- 老年代回收算法：标记、清除、整理算法（GC并行，业务线程暂停）；

###相关要点###
- 多线程垃圾回收器，年轻代和老年代回收垃圾时都会触发STW；
- 吞吐量比串行GC更高，STW停顿时间更短；

###适用场景###
- 多核CPU，对吞吐量有要求；

###使用命令###
- -XX：ParallelGCThreads=N 指定GC线程数，默认为CPU核心数；
- -XX:+UseParallelGC
- -XX:+UseParallelOldGC
- -XX:+UseParallelGC -XX:+UseParallelOldGC
- JDK6,7,8默认使用ParallelGC

##CMS GC##
###堆区内存模型###
- 堆 = 年轻代 + 老年代；
- 年轻代 = Eden区 + S0区 + S1区；
###默认比例###
- 年轻代 : 老年代 = 1:2
- Edem : S0: S1 = 8:1:1
###相关GC算法###
- 年轻代回收算法：标记、复制算法（GC并行，业务线程暂停）；
- 老年代回收算法：标记、清除算法（GC并行，业务线程并行）；
###相关要点###
- 年轻代回收算法会导致STW；
- 老年代GC可以和业务线程并发进行；
- 老年代回收算法做了优化：
- 1，使用标记、清除算法，不对老年代进行整理，而是使用空闲列表来管理内存空间的回收；
- 2，标记、清除算法和业务线程并行处理；默认情况，CMS使用的并发线程数等于 CPU核心数的 1/4；

###CMS GC的六个阶段###
- 阶段 1: Initial Mark（初始标记）
- 阶段 2: Concurrent Mark（并发标记）
- 阶段 3: Concurrent Preclean（并发预清理）
- 阶段 4: Final Remark（最终标记）
- 阶段 5: Concurrent Sweep（并发清除）
- 阶段 6: Concurrent Reset（并发重置）

&emsp;阶段1和4会导致STW，2356阶段GC线程和业务线程并发进行；

###适用场景###
- 多核CPU，要求GC停顿时间短；

###使用命令###
- - XX:+UseConcMarkSweepGC（Java 8 and Java 11）

##G1 GC（Garbage-First）##
###堆区内存模型###
- 堆区内存被划分为多个小块，每个块会根据需要被定义为Eden区，Survivor区，old区；
- 年轻代 = 所有Eden生区 + 所有Survivor区；
- 老年代 = 所有Old区；

###相关要点###
- 每次只处理一部分内存块，称为此次 GC 的回收集。每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。
- 垃圾最多的小块会被优先收集；

###适用场景###
- 多核CPU，对GC导致的暂停延时和稳定性有要求的场景；

###使用命令###
- -XX:+UseG1GC -XX:MaxGCPauseMillis=50
- JDK9之后，默认是G1 GC

##GC选择##
- 1. 如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
- 2. 如果系统考虑低延迟有限，每次GC时间尽量短，用 CMS GC；
- 3. 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC；

###对于内存大小的考量###
- 1. 一般 4G 以上，算是比较大，用 G1 的性价比较高；
- 2. 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC；


##补充##
###ZGC###
主要的特点包括:
 
- 1.GC 最大停顿时间不超过 10ms；
- 2.堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆内存（JDK13 升至 16TB）；
- 3.与 G1 相比，应用吞吐量下降不超过 15%；
- 4.当前只支持 Linux/x64 位平台，JDK15 后支持 MacOS 和Windows 系统；

###Shenandoah###
&emsp;除了对老年代GC回收做了并行处理，对年轻代GC回收也做了并行处理；

###ZGC和Shenandoah GC适用场景###
&emsp;大内存，对GC造成的延时有较高要求时比较适用；